<docs lang="markdown">
[TODO: write documentation for this plugin.]
</docs>

<config lang="json">
{
    "name": "SearchBioImageModelZoo",
    "type": "web-python",
    "version": "0.1.0",
    "description": "BioImage.IO Chatbot Extension for getting information about models, applications, datasets, etc. in the BioImage Model Zoo.",
    "tags": [],
    "ui": "",
    "cover": "",
    "inputs": null,
    "outputs": null,
    "flags": [],
    "icon": "extension",
    "api_version": "0.1.8",
    "env": "",
    "permissions": [],
    "requirements": ["pydantic"],
    "dependencies": []
}
</config>

<script lang="python">
import sys
import io
from imjoy import api
from js import fetch
from pydantic import BaseModel, Field
from typing import Callable, Type, Optional
from typing import List, Optional, Dict, Any

class ResourceType(str):
    MODEL = "model"
    DATASET = "dataset"
    APPLICATION = "application"

class ModelZooSearchInput(BaseModel):
    """Search the BioImage Model Zoo (bioimage.io) resource items such as models, applications, datasets, etc. in the model zoo and return detailed information."""
    keywords: List[str] = Field(..., description="List of keywords to search for in the model zoo.")
    top_k: int = Field(3, description="The maximum number of search results to return. Default is 3. Please be aware each item may contain a large amount of data.")
    type: Optional[ResourceType] = Field(None, description="The type of resource to search for. Options include 'model', 'dataset', 'application'.")

def normalize_text(text: str) -> str:
    return text.replace('_', ' ').lower()

def matches_keywords(text: str, keywords: List[str]) -> bool:
    normalized_text = normalize_text(text)
    return any(keyword in normalized_text for keyword in keywords)

def search_item(item: Dict[str, Any], keywords: List[str]) -> bool:
    search_fields = [item.get('name', ''), item.get('description', '')] + [tag for tag in item.get('tags', [])]
    search_fields += [author['name'] for author in item.get('authors', [])]
    return any(matches_keywords(field, keywords) for field in search_fields)

def search(config: ModelZooSearchInput, resource_items: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
    keywords = [normalize_text(keyword) for keyword in config.keywords]
    filtered_items = []
    for item in resource_items:
        if config.type and item.get('type') != config.type:
            continue
        if search_item(item, keywords):
            filtered_items.append(item)
        if len(filtered_items) == config.top_k:
            break
    return filtered_items

async def load_model_info():
    response = await fetch("https://bioimage-io.github.io/collection-bioimage-io/collection.json")
    model_info = await response.json()
    model_info = model_info.to_py()
    resource_items = model_info['collection']
    return resource_items

def execute_code(script, context=None):
    if context is None:
        context = {}

    # Redirect stdout and stderr to capture their output
    original_stdout = sys.stdout
    original_stderr = sys.stderr
    sys.stdout = io.StringIO()
    sys.stderr = io.StringIO()

    try:
        # Create a copy of the context to avoid modifying the original
        local_vars = context.copy()

        # Execute the provided Python script with access to context variables
        exec(script, local_vars)

        # Capture the output from stdout and stderr
        stdout_output = sys.stdout.getvalue()
        stderr_output = sys.stderr.getvalue()

        return {
            "stdout": stdout_output,
            "stderr": stderr_output,
            # "context": local_vars  # Include context variables in the result
        }
    except Exception as e:
        return {
            "stdout": "",
            "stderr": str(e),
            # "context": context  # Include context variables in the result even if an error occurs
        }
    finally:
        # Restore the original stdout and stderr
        sys.stdout = original_stdout
        sys.stderr = original_stderr

async def register_chatbot_extension(register):
    resource_items = await load_model_info()
    types = set()
    tags = set()
    for resource in resource_items:
        types.add(resource['type'])
        tags.update(resource['tags'])
    types = list(types)
    tags = list(tags)[:10]
    resource_item_stats = f"""Each item contains the following fields: {list(resource_items[0].keys())}\nThe available resource types are: {types}\nSome example tags: {tags}\n""" #Here is an example: {resource_items[0]}

    class ModelZooInfoScript(BaseModel):
        script: str = Field(..., description="""Executable python script (Python runtime: Pyodide) for querying information""")
    
    ModelZooInfoScript.__doc__ = (
    "Querying statistical details about models, applications, datasets in the BioImage Model Zoo (bioimage.io) by generating and executing "
    "Python 3 scripts in the browser with Pyodide. Utilize 'resources', a local variable with zoo resources as dictionaries, "
    "for data instead of server requests. Handle missing fields in zoo items. Output query responses to stdout. "
    "Remember to filter out resource items based on the 'type' key."
    "Avoid using requests for remote server interactions. 'resources' variable details:\\n"
    ) + resource_item_stats

    def get_schema():
        return ModelZooInfoScript.schema()

    async def execute(req):
        result = execute_code(req['script'], {"resources": resource_items})
        return result

    await register({
        "_rintf": True,
        "name": "ModelZooInfoScript",
        "description": ModelZooInfoScript.__doc__,
        "get_schema": get_schema,
        "execute": execute
    })

    def get_search_schema():
        return ModelZooSearchInput.schema()

    async def execute_search(config: dict):
        config = ModelZooSearchInput.parse_obj(config)
        result = search(config, resource_items)
        return result

    await register({
        "_rintf": True,
        "name": "ModelZooSearch",
        "description": ModelZooSearchInput.__doc__,
        "get_schema": get_search_schema,
        "execute": execute_search
    })



class ImJoyPlugin():
    async def setup(self):
        if api.registerChatbotExtension:
            # Loading inside the chatbot
            await register_chatbot_extension(api.registerChatbotExtension)
            await api.showMessage("BioImage Model Zoo Chatbot Extension registered")
        else:
            # Use together with the chatbot
            chatbot = await api.getWindow("BioImage.IO Chatbot")
            if chatbot:
                await register_chatbot_extension(chatbot.registerExtension)
                await api.showMessage("BioImage Model Zoo Chatbot Extension registered")

        await api.log('initialized')

api.export(ImJoyPlugin())
</script>
